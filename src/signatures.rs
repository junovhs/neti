// src/signatures.rs
use crate::config::Config;
use crate::discovery;
use crate::lang::Lang;
use crate::skeleton;
use crate::tokens::Tokenizer;
use anyhow::{Context, Result};
use colored::Colorize;
use rayon::prelude::*;
use std::fs;
use std::path::Path;
use tree_sitter::{Language, Parser, Query, QueryCursor};

#[derive(Debug, Clone, Copy)]
pub struct SignatureOptions {
    pub copy: bool,
    pub stdout: bool,
}

/// Generates a type-surface signature map of the codebase.
///
/// # Errors
/// Returns error if file discovery or reading fails.
pub fn run(opts: &SignatureOptions) -> Result<()> {
    let mut config = Config::new();
    config.load_local_config();

    println!("{}", "üîç Scanning type surface...".cyan());

    let files = discovery::discover(&config)?;
    let signatures: Vec<String> = files
        .par_iter()
        .filter_map(|p| process_file(p))
        .collect();

    let output = format_output(&signatures);
    let tokens = Tokenizer::count(&output);

    println!(
        "‚ú® Extracted {} signatures (~{} tokens)",
        signatures.len(),
        tokens
    );

    if opts.stdout {
        println!("{output}");
    } else if opts.copy {
        crate::clipboard::smart_copy(&output)?;
        println!("{}", "‚úì Copied to clipboard".green());
    } else {
        let out_path = Path::new("SIGNATURES.rs"); // Use .rs for syntax highlighting hint
        fs::write(out_path, &output).context("Failed to write output file")?;
        println!("‚úì Written to {}", out_path.display().to_string().green());
    }

    Ok(())
}

fn process_file(path: &Path) -> Option<String> {
    let content = fs::read_to_string(path).ok()?;
    let ext = path.extension().and_then(|s| s.to_str())?;
    let lang = Lang::from_ext(ext)?;

    // 1. Filter: Keep only public/exported items + impl blocks
    let filtered_content = extract_exports(lang, &content)?;

    // 2. Clean: Skeletonize (strip bodies)
    let clean_content = skeleton::clean(path, &filtered_content);

    if clean_content.trim().is_empty() {
        return None;
    }

    let rel_path = path.to_string_lossy();
    Some(format!(
        "// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n// {rel_path}\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n{clean_content}\n"
    ))
}

fn extract_exports(lang: Lang, content: &str) -> Option<String> {
    // If it's Python, we don't have explicit visibility modifiers in the AST reliably without strict naming conventions.
    // For now, return full content (skeleton will reduce it).
    if lang == Lang::Python {
        return Some(content.to_string());
    }

    let grammar = lang.grammar();
    let query_str = lang.q_exports();
    let query = compile_query(grammar, query_str)?;

    let mut parser = Parser::new();
    if parser.set_language(grammar).is_err() {
        return None;
    }

    let tree = parser.parse(content, None)?;
    let mut cursor = QueryCursor::new();
    let matches = cursor.matches(&query, tree.root_node(), content.as_bytes());

    // We want to reconstruct the file but ONLY with the ranges identified as exports.
    let mut ranges = Vec::new();
    for m in matches {
        for capture in m.captures {
            ranges.push(capture.node.byte_range());
        }
    }

    if ranges.is_empty() {
        return None;
    }

    // Merge overlapping ranges and extract text
    Some(merge_and_extract(content, ranges))
}

fn merge_and_extract(source: &str, mut ranges: Vec<std::ops::Range<usize>>) -> String {
    if ranges.is_empty() {
        return String::new();
    }

    ranges.sort_by_key(|r| r.start);

    let mut merged = Vec::new();
    let mut current = ranges[0].clone();

    for next in ranges.into_iter().skip(1) {
        if next.start <= current.end {
            // Overlap or adjacent, extend current
            current.end = std::cmp::max(current.end, next.end);
        } else {
            merged.push(current);
            current = next;
        }
    }
    merged.push(current);

    let mut result = String::new();
    for range in merged {
        result.push_str(&source[range]);
        result.push('\n');
    }

    result
}

fn format_output(signatures: &[String]) -> String {
    let mut out = String::new();
    out.push_str("// AUTO-GENERATED BY: slopchop signatures\n");
    out.push_str("// This file contains the PUBLIC TYPE SURFACE of the codebase.\n");
    out.push_str("// Use this to understand available types, functions, and traits.\n\n");

    for sig in signatures {
        out.push_str(sig);
        out.push('\n');
    }
    out
}

fn compile_query(lang: Language, pattern: &str) -> Option<Query> {
    Query::new(lang, pattern).ok()
}